База данных
===========

Таблицы:
--------

Клиенты - tb_customers
Кошельки - tb_wallets
Города - tb_cities
Страны - tb_countries
Транзакции - tb_transactions
Валюты - tb_currencies
Котировки - tb_rates 


По условию, счёт должен быть привязан к имени владельца, а также к городу и стране его проживания.

Имеет смысл разделить системные настройки счёта и "мета-данные" (город, имя), чтобы получить прирост производительности при манипуляциях с счетом.

Более того, для дальнейшей потенциальной горизонтальной расширяемости, стоит предположит заранее, что у одного пользователя может быть более одного счёта.
По этим причинам, у нас есть отдельные сущности "кошелек" и "клиент".

Чтобы не дублировать одинаковые данные в БД, имело смысл вывести города и страны в отдельные таблицы.

Валюты и котировки разбиты также на две таблицы, потому что, по условию, мы должны хранить историю котировок.

Транзакции имеют ссылки на кошельки отправителя и получателя. В случае, "пополнения" кошелька поле "отправителя" указывается в NULL.
Такая система сделана для упрощения системы и запросов.



Избыточность данных.
-------------------

Несколько раз пришлось НФ3 для повышения проиводительности:

tb_currencies содержит поле rate, которое содержит значение последней котировки для каждой валюты.

Такое решение имеет смысл для ускорения работы системы и упрощения запросов к БД.
Более того, запрос о получении последней котировки для валюты усложняется тем, что он может быть выполнен до ежедневного обновления котировок. И придется брать котировку не за текущий день, а за "последний".


tb_transactions содержит поля senderSum, receiverSum и sum.

senderSum - сумма в валюте отправителя
receiverSum - сумма в валюте получателя
sum - сумма в USD

Эти данные стоит сохранить, потому что:
- опять-таки, ускорит работу системы и очень сильно упростит запросы.
- полезно иметь такую информацию в качестве логов, при поиске вероятных ошибок



Типы данных
-----------

Для валют используется decimal(20,10), потому что, непонятно на какие примерно данные должна быть расчитана система.
Данная точность была указана "на всякий случай" и порождает избыточность данных.

Операции со значениями на данный момент выполнены при помощи обычных математических операций. Однако, для повышения точности, при подготовке проекта к релизу, следует заменить их на операции BCMath (http://php.net/manual/ru/book.bc.php).
Не на всех ПК РНР скомпилирован с поддержкой BCMath, потому, побоялся использовать его, чтобы не было проблем при деплое.

Для валют был использован decimal вместо bigint.
При хранении в Decimal, значения хранятся "как есть", в противовес bigint, где всякий раз нужно умножать/делить на 100 (или более).
Потому, отсутствие необходимости такого преобразования, исключит в дальнейшем повление ошибок, вызванных человеческим фактором.
С другой стороны, bigint немного выигрывает в скорости.



Описание кода
=============

Загрузка котировок
------------------

Стек вызовов:

```
api\modules\v1\controllers\RatesController::actionUpdatebydate()
api\modules\v1\models\Rate::batchUpdate()

```

Объем загружаемых данных может быть достаточно большим, чтобы обработка вылезла за пределы памяти.
Потому, берем количество пришедших котировок, и обрабатываем их "по странично" - берем по очереди по 20 объектов, обрабатываем каждый и сохраняем.
Также, здесь происходит обновление текущего курса валюты в таблицы ```tb_currencies```.


Регистрация Кошелька
--------------------

Стек вызовов:

```
api\modules\v1\models\Wallet::save()
api\modules\v1\models\Wallet::beforeSave()
```

Использованы возможности фреймворка. Перед созранением модели wallet происходит действие beforeSave, в которой происходит поиск и, при необходимости, создание сущностей Country, City, Customer, Currenсy.
Всё происходит в транзакции, хоть это и не запрограммировано явно, ибо её обеспечивает нам фреймворк.


Пополнение кошелька / перевод денег
-----------------------------------

Стек вызовов:

```
api\modules\v1\controllers\WalletsController::actionRecharge() / actionTransfer()
api\modules\v1\models\forms\TransactionForm::save()
```

По сути, пополнение кошелька и перевод, при текущей архитектуре - одно и то же действие, но отличаются тем, что при пополнении кошелька, отправитель отсутствует.

Само действие происходит в ```TransactionForm::save()```, а именно:
- высчитываются курсы (USD, отправителя и получателя)
- создаётся новая транзакция
- изменяются балансы кошельков


Генерация CSV
-------------

Стек вызовов:
```
backend\controllers\TransactionsController::actionDownload()
```

Здесь мы отдаем подменяем заголовки и отдаем содержимое csv файла.
В данном методе я отказался от транзакций БД, потому что:
- всё же, не стоит ими злоупотреблять, потому что они немного понижают производительность
- валютные транзакции нельзя изменять или удалять
- в случае, если во время выполнения метода будет добавлена новая валютная транзакция, данные могут быть выданы не верные, потому что получаю их в несколько запросов, и последующий запрос может захватить строки из предыдущего. Чтобы избежать это, перед генерацией отчета, я получаю даты первой и последней транзакции и далее, использую их для последующих обращений к БД. В таком случае, добавление новой транзакции не повлияет на результат.

Тут также, как и в загрузке котировок, получаю данные "постранично". Для экономии памяти, отправляю результат прямиком в поток php://output.



TODO
====

Не реализовано
--------------

К сожалению, на данный момент пока не реализованы некоторые моменты.

Отсутствует кеширование.
Имеет смысл закешировать значения "валюта -> текущий курс к USD", чтобы исключить дополнительный запрос к БД.
В отличие от других таблиц, количество валют более-менее исчисляемо (сотни, в случае обычных валют и тысячи в случае альткоинов), потому возможна полная загрузка в память.


Оптимизация
-----------

Вероятно, имеет смысл хранить значения "сальдо" кошельков на определенные периоды. Это ускорит подсчет суммы всех операций (в отчёте), а также упростит пересчет текущего баланса кошелька на основе транзакций, в случае возникновения ошибки.


Возможные ошибки
----------------

В нескольких местах в коде, используются "постраничные" обработки результатов, когда, в цикле выполняется ряд операций с БД, для сохранения памяти.
Известна проблема, что при работе такого алгоритма, РНР может потерять соединение с БД. Однако, в текущем приложении я такую ошибку не встретил.
